<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HuResearch - Research Assistant</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- PDF.js for Custom Rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Set worker script for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Georgia:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #fcfcfc; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Animations */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in-up { animation: fadeInUp 0.3s ease-out forwards; }
        
        @keyframes spin-slow {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .animate-spin-slow {
            animation: spin-slow 3s linear infinite;
        }

        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        
        /* PDF Container Styles (Fixed for Desktop Zooming) */
        #pdf-render-container {
            overflow: auto;
            background-color: #e5e5e5;
            height: 100%;
            position: relative;
            text-align: center; /* Center the inline-block wrapper */
            padding: 20px;
            touch-action: pan-x pan-y; 
        }
        
        /* Wrapper for Canvas + Text Layer */
        .pdf-page-wrapper {
            position: relative;
            display: inline-block; /* Prevents flexbox overflow distortion */
            margin: 0 auto;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            user-select: none;
            transition: transform 0.1s ease-out; 
            text-align: left; /* Reset text align for inner absolute layers */
        }

        canvas {
            display: block;
        }

        /* Floating Pagination Capsule (Fixed Visibility) */
        .floating-pagination {
            position: fixed; /* Fixed relative to viewport */
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(8px);
            border-radius: 9999px;
            padding: 8px 24px;
            display: flex;
            align-items: center;
            gap: 24px;
            color: white;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            z-index: 9999; /* Extremely high z-index to guarantee visibility */
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            .floating-pagination {
                bottom: 90px; /* Sits perfectly above the bottom mobile nav */
                padding: 8px 20px;
                gap: 16px;
            }
            .floating-pagination.hide-on-mobile {
                display: none !important;
            }
        }

        /* PDF.js Text Layer */
        .textLayer {
            position: absolute;
            text-align: initial;
            left: 0; top: 0; right: 0; bottom: 0;
            overflow: hidden;
            opacity: 0.2;
            line-height: 1.0;
            pointer-events: auto;
        }

        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }

        /* Highlight Layer (Drawing & Comments) */
        .highlight-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; 
            z-index: 10;
        }

        .highlight-layer.drawing-mode {
            pointer-events: auto;
            cursor: crosshair;
        }
        
        .highlight-layer.comment-mode {
            pointer-events: auto;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="%23f59e0b" stroke="%23ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7.9 20A9 9 0 1 0 4 16.1L2 22Z"/></svg>') 0 24, pointer; 
        }

        .drawn-highlight {
            position: absolute;
            background-color: rgba(253, 224, 71, 0.4); 
            border: 1px solid rgba(234, 179, 8, 0.6);
            pointer-events: none;
        }

        /* Comment Marker */
        .comment-marker {
            position: absolute;
            width: 24px;
            height: 24px;
            margin-top: -24px; 
            cursor: pointer;
            z-index: 20;
            color: #f59e0b; 
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));
            transition: transform 0.1s;
            pointer-events: auto;
        }
        .comment-marker:hover {
            transform: scale(1.2);
            color: #d97706;
        }

        ::selection {
            background: rgba(0, 0, 255, 0.3);
        }

        /* --- RESEARCH RESULT CARD STYLES --- */
        .result-card { 
            background: #fff; 
            border: 1px solid #e5e7eb; 
            padding: 16px; 
            border-radius: 12px; 
            margin-bottom: 12px; 
            position: relative; 
            display: flex;
            flex-direction: column;
            transition: box-shadow 0.2s;
        }
        .result-card:hover { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05); }
        .result-card.handoff { border-style: dashed; background: #fafafa; }
        
        .res-title { 
            display: block;
            font-family: Georgia, "Times New Roman", Times, serif;
            font-size: 19px;
            font-weight: 600;
            color: #111827;
            text-decoration: none;
            margin-bottom: 10px;
            line-height: 1.35;
        }
        .res-title:hover { text-decoration: underline; }
        
        .res-meta { 
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: #6b7280;
            margin-bottom: 12px;
        }
        .res-snippet { 
            font-family: Georgia, "Times New Roman", Times, serif;
            font-size: 15px;
            color: #1f2937;
            line-height: 1.7;
            margin-bottom: 18px;
            word-wrap: break-word; 
        }
        .res-snippet mark {
            background-color: rgba(234, 179, 8, 0.42);
            padding: 0 2px;
            border-radius: 2px;
        }

        .res-footer { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-top: auto; }
        .badge { font-size: 12px; padding: 4px 10px; border-radius: 6px; border: 1px solid #e5e7eb; background: #f3f4f6; color: #6b7280; text-decoration: none; font-weight: 500; }
        .badge.pdf { background: #fee2e2; color: #b91c1c; border-color: #fecaca; }
        
        .copy-btn { 
            margin-left: auto; 
            background: #eef2f7; 
            color: #1f2937; 
            border: 1px solid transparent; 
            font-size: 13px; 
            font-weight: 600;
            cursor: pointer; 
            padding: 8px 16px; 
            border-radius: 8px;
            transition: all 0.2s;
        }
        .copy-btn:hover { filter: brightness(0.95); transform: translateY(-1px); }

        /* Filter Styles */
        .filter-label { cursor: pointer; user-select: none; display: flex; align-items: center; }
        .filter-label input { display: none; }
        .filter-label span { 
            display: block; 
            padding: 6px 14px; 
            border-radius: 99px; 
            font-size: 13px; 
            border: 1px solid #e5e7eb; 
            background: #fff; 
            color: #6b7280; 
            transition: all 0.1s; 
        }
        .filter-label input:checked + span { background: #02050a; border-color: #02050a; color: #fff; }
        .filter-label.pdf-toggle span { font-weight: 600; border-color: #b91c1c; color: #b91c1c; }
        .filter-label.pdf-toggle input:checked + span { background: #b91c1c; color: #fff; border-color: #b91c1c; }

        /* Easter Egg */
        .easter-egg-card { display: none; flex-direction: column; align-items: center; text-align: center; background: #fff; border: 1px solid #e5e7eb; border-radius: 20px; padding: 40px 24px; margin: 0 auto 30px auto; max-width: 400px; box-shadow: none; }
        .easter-egg-card.active { display: flex; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .ee-img { width: 140px; height: 140px; border-radius: 50%; object-fit: cover; margin-bottom: 20px; background: #f3f4f6; }
        .ee-name { font-size: 22px; font-weight: 700; color: #111827; margin-bottom: 8px; font-family: Georgia, serif; }
        .ee-bio { font-size: 15px; color: #6b7280; }
        @keyframes popIn { from { opacity: 0; transform: scale(0.9) translateY(10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
        
        .emoji-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 999; display: none; }
        .emoji-container.active { display: block; }
        .float-emoji { position: absolute; bottom: -50px; font-size: 40px; opacity: 0; animation: floatUp 4s ease-out forwards; }
        @keyframes floatUp { 
            0% { transform: translateY(0) scale(0.5) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            80% { opacity: 0.8; }
            100% { transform: translateY(-110vh) scale(1.2) rotate(20deg); opacity: 0; }
        }
        
        .add-btn-round { width: 36px; height: 36px; border-radius: 50%; border: 1px solid #e5e7eb; display: flex; align-items: center; justify-content: center; color: #9ca3af; transition: all 0.2s; }
        .add-btn-round:hover { color: #2563eb; background: #eff6ff; border-color: #bfdbfe; }
        
        /* Prominent Add Button Style */
        .add-btn-prominent {
            width: 40px; height: 40px; 
            border-radius: 50%; 
            background-color: #111827; /* Stone 900 */
            color: white;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.2s;
            border: none;
        }
        .add-btn-prominent:hover {
            background-color: #000;
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        /* Highlight Note Style */
        .highlight-note { border-left: 3px solid #fbbf24; background: #fffbeb; }
        .comment-note { border-left: 3px solid #f59e0b; background: #fff7ed; }

        /* Mode Active States */
        .tool-btn-active { background-color: #fef08a !important; color: #854d0e !important; border-color: #fde047; }
        .comment-btn-active { background-color: #fef3c7 !important; color: #b45309 !important; border-color: #fcd34d; }
    </style>
</head>
<body class="text-stone-900 h-screen w-full flex overflow-hidden selection:bg-stone-200">

    <!-- Sidebar (Desktop) -->
    <aside class="w-64 bg-stone-100 border-r border-stone-200 flex-col justify-between hidden md:flex shrink-0">
        <div>
            <div class="p-8 pb-4">
                <!-- Enlarged Desktop Logo -->
                <img src="https://res.cloudinary.com/dpnpu5vn5/image/upload/v1770818336/HuResearch_Logo_cjq8pf.png" alt="HuResearch" class="h-14 object-contain">
            </div>
            <nav class="px-4 space-y-1" id="desktop-nav">
                <!-- Nav items injected by JS -->
            </nav>
        </div>
    </aside>

    <!-- Main Content -->
    <main id="main-content" class="flex-1 overflow-hidden relative flex flex-col">
        <!-- Dynamic View Injected Here -->
    </main>

    <!-- Comment Modal -->
    <div id="comment-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/20 backdrop-blur-sm">
        <div class="bg-stone-900 rounded-xl shadow-2xl border border-stone-700 w-80 p-4 transform scale-100 transition-all animate-fade-in-up">
            <div class="flex justify-between items-center mb-3">
                <h3 class="font-bold text-white text-sm" id="comment-modal-title">Add a comment</h3>
                <button onclick="closeCommentModal()" class="text-stone-400 hover:text-white"><i data-lucide="x" width="16"></i></button>
            </div>
            <textarea id="comment-text" class="w-full h-24 bg-stone-800 border border-stone-700 rounded-lg p-3 text-sm text-stone-200 focus:ring-1 focus:ring-stone-500 outline-none resize-none mb-3 placeholder-stone-500" placeholder="Type your comment..."></textarea>
            <div class="flex justify-end gap-2">
                <button onclick="closeCommentModal()" class="px-3 py-1.5 text-xs font-medium text-stone-400 hover:text-stone-200">Cancel</button>
                <button onclick="saveComment()" class="px-3 py-1.5 text-xs font-medium bg-blue-600 text-white rounded-lg hover:bg-blue-500">Post</button>
            </div>
        </div>
    </div>

    <!-- Emoji Container for Easter Eggs -->
    <div id="emojiContainer" class="emoji-container"></div>

    <!-- Notification Toast (Moved to top center for mobile to prevent overlap) -->
    <div id="toast-container" class="fixed top-24 md:top-auto md:bottom-6 left-1/2 -translate-x-1/2 md:left-auto md:translate-x-0 md:right-6 z-[9999] pointer-events-none flex flex-col items-center md:items-end w-max max-w-[90vw]"></div>

    <!-- Mobile Nav (Bottom) -->
    <div class="md:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-stone-200 z-50 flex justify-around p-3 pb-safe" id="mobile-nav">
        <!-- Mobile nav items injected by JS -->
    </div>

    <script>
        /**
         * INDEXED DB (PERSISTENT FILE STORAGE)
         */
        const DB_NAME = 'FrauedDB';
        const DB_VERSION = 1;
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = (e) => reject("DB Error");
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('pdfs')) {
                        db.createObjectStore('pdfs', { keyPath: 'id' });
                    }
                };
                request.onsuccess = (e) => {
                    db = e.target.result;
                    resolve(db);
                };
            });
        }

        async function savePDFToDB(pdfObj) {
            if(!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(['pdfs'], 'readwrite');
                const store = tx.objectStore('pdfs');
                store.put(pdfObj);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject();
            });
        }

        async function loadPDFsFromDB() {
            if(!db) await initDB();
            return new Promise((resolve) => {
                const tx = db.transaction(['pdfs'], 'readonly');
                const store = tx.objectStore('pdfs');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => resolve([]);
            });
        }

        async function deletePDFFromDB(id) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(['pdfs'], 'readwrite');
                const store = tx.objectStore('pdfs');
                store.delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject();
            });
        }

        /**
         * UTILITIES
         */
        const encode = encodeURIComponent;
        function mkEl(tag, cls, txt) { const el = document.createElement(tag); if(cls) el.className=cls; if(txt) el.textContent=txt; return el; }
        function escapeRegExp(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
        
        function highlightText(element, query) {
            if (!query || !element.textContent) return;
            const terms = query.split(/\s+/).filter(t => t.length > 2);
            if (terms.length === 0) return;
            try {
                const pattern = new RegExp(`(${terms.map(escapeRegExp).join('|')})`, 'gi');
                const walk = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);
                const nodes = []; while(walk.nextNode()) nodes.push(walk.currentNode);
                nodes.forEach(node => {
                    if (node.parentNode.nodeName === 'MARK') return;
                    if (pattern.test(node.nodeValue)) {
                        const span = document.createElement('span');
                        span.innerHTML = node.nodeValue.replace(pattern, '<mark>$1</mark>');
                        node.parentNode.replaceChild(span, node);
                    }
                });
            } catch (e) {}
        }

        /**
         * STATE MANAGEMENT
         */
        const defaultState = {
            activeTab: 'research',
            library: [],
            pdfs: [],
            annotations: {},
            search: {
                query: '',
                results: [],
                loading: false,
                searched: false,
                sources: { openalex: true, crossref: true, internetarchive: false, jstor: false, muse: true },
                pdfsOnly: false,
                easterEgg: null
            },
            citations: { style: 'APA', copiedId: null },
            pdfViewer: { 
                activePdf: null, 
                pageNum: 1, 
                numPages: 0, 
                scale: 1.0, 
                pdfDoc: null, 
                highlightMode: false,
                commentMode: false,
                editingCommentId: null
            }
        };

        let savedData = localStorage.getItem('fraued_data');
        let state = savedData ? { ...defaultState, ...JSON.parse(savedData), pdfViewer: defaultState.pdfViewer, search: defaultState.search } : defaultState;
        
        state.pdfs = []; 

        /**
         * APP LOGIC
         */

        async function init() {
            await initDB();
            
            const storedPDFs = await loadPDFsFromDB();
            if (storedPDFs && storedPDFs.length > 0) {
                state.pdfs = storedPDFs.map(pdf => ({
                    ...pdf,
                    url: URL.createObjectURL(pdf.blob)
                }));
            }

            renderNav();
            renderView();
            lucide.createIcons();
            saveData();
        }

        function saveData() {
            localStorage.setItem('fraued_data', JSON.stringify({
                library: state.library,
                annotations: state.annotations,
                citations: state.citations
            }));
        }

        // --- Navigation ---
        function setActiveTab(tab) {
            state.activeTab = tab;
            state.pdfViewer.activePdf = null;
            renderNav();
            renderView();
        }

        function renderNav() {
            const tabs = [
                { id: 'research', label: 'Research', icon: 'search' },
                { id: 'citations', label: 'Citations', icon: 'quote', badge: state.library.length },
                { id: 'pdf', label: 'PDF Reader', icon: 'file-text', badge: state.pdfs.length }
            ];
            // Desktop
            document.getElementById('desktop-nav').innerHTML = tabs.map(tab => `
                <button onclick="setActiveTab('${tab.id}')" 
                    class="w-full flex items-center justify-between px-4 py-3 rounded-xl transition-all duration-200 ${state.activeTab === tab.id ? 'bg-white shadow-sm text-stone-900 font-medium' : 'text-stone-500 hover:bg-stone-200/50 hover:text-stone-700'}">
                    <div class="flex items-center gap-3"><i data-lucide="${tab.icon}" width="20"></i><span>${tab.label}</span></div>
                    ${tab.badge > 0 ? `<span class="bg-stone-200 text-stone-600 text-[10px] font-bold px-2 py-0.5 rounded-full">${tab.badge}</span>` : ''}
                </button>
            `).join('');
            // Mobile
            document.getElementById('mobile-nav').innerHTML = tabs.map(tab => `
                <button onclick="setActiveTab('${tab.id}')" class="p-2 rounded-full transition-colors ${state.activeTab === tab.id ? 'bg-stone-900 text-white' : 'text-stone-500'}">
                    <i data-lucide="${tab.icon}" width="24"></i>
                </button>
            `).join('');
            lucide.createIcons();
        }

        function renderView() {
            const main = document.getElementById('main-content');
            main.innerHTML = '';
            if (state.pdfViewer.activePdf) {
                renderPDFReaderDOM(main);
                setTimeout(() => renderPDFPage(state.pdfViewer.pageNum), 0);
            } else {
                switch(state.activeTab) {
                    case 'research': renderResearch(main); break;
                    case 'citations': renderCitations(main); break;
                    case 'pdf': renderPDFList(main); break;
                }
            }
            lucide.createIcons();
        }

        // --- FETCHERS & SEARCH (Existing) ---
        async function safeFetch(promise) { try { return await promise; } catch (err) { return []; } }
        async function fetchOpenAlex(q) { const url = `https://api.openalex.org/works?search=${encode(q)}&per_page=20&filter=type:journal-article,is_paratext:false`; const res = await fetch(url); if (!res.ok) throw new Error(res.status); const data = await res.json(); return data.results.map(w => ({ title: w.title, url: w.doi ? `https://doi.org/${w.doi}` : w.id, source: 'OpenAlex', date: w.publication_year ? String(w.publication_year) : '', journal: w.primary_location?.source?.display_name || '', doi: w.doi ? w.doi.replace('https://doi.org/', '') : null, pdf: w.open_access?.oa_url || null, authors: w.authorships.map(a => ({ display_name: a.author.display_name })), snippet: '', isOpenAccess: !!w.open_access?.oa_url })); }
        async function fetchCrossref(q) { const url = `https://api.crossref.org/works?query=${encode(q)}&filter=type:journal-article&rows=20&mailto=search@daag.app`; const res = await fetch(url); if (!res.ok) throw new Error(res.status); const data = await res.json(); return (data.message.items || []).map(i => { let pdfUrl = null; if (i.link && Array.isArray(i.link)) { const found = i.link.find(l => l['content-type'] === 'application/pdf'); if (found) pdfUrl = found.URL; } return { title: i.title?.[0] || 'Untitled', url: i.URL, source: 'Crossref', date: i.created?.['date-parts']?.[0]?.[0] ? String(i.created['date-parts'][0][0]) : '', journal: i['container-title']?.[0] || '', doi: i.DOI, pdf: pdfUrl, authors: i.author ? i.author.map(a => ({ display_name: (a.given ? a.given + ' ' : '') + a.family })) : [], snippet: '', isOpenAccess: !!pdfUrl }; }); }
        async function fetchInternetArchive(q) { const qStr = `(${encode(q)}) AND mediatype:(texts)`; const url = `https://archive.org/advancedsearch.php?q=${qStr}&fl[]=identifier,title,description,year&rows=15&output=json`; const res = await fetch(url); if (!res.ok) throw new Error(res.status); const data = await res.json(); return (data.response?.docs || []).map(d => ({ title: d.title, url: `https://archive.org/details/${d.identifier}`, source: 'Internet Archive', date: d.year ? String(d.year) : '', snippet: Array.isArray(d.description) ? d.description[0] : (d.description || ''), pdf: `https://archive.org/download/${d.identifier}/${d.identifier}.pdf`, journal: 'Archive.org', authors: [], isOpenAccess: true })); }
        
        // --- NEW: PDF IMPORT LOGIC ---
        async function importExternalPDF(url, title) {
            showToast("Attempting to import PDF...");
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error("Fetch failed");
                const blob = await response.blob();
                
                // Create File object
                const file = new File([blob], `${title}.pdf`, { type: "application/pdf" });
                
                const id = Date.now().toString();
                const newPdf = {
                    id: id,
                    name: title || "Imported Document",
                    blob: file, 
                    url: URL.createObjectURL(file),
                    date: new Date().toLocaleDateString()
                };
                
                // Save
                state.pdfs.push(newPdf);
                await savePDFToDB({ id: newPdf.id, name: newPdf.name, blob: newPdf.blob, date: newPdf.date });
                
                // Switch tab and open
                setActiveTab('pdf');
                openPdf(state.pdfs.length - 1);
                showToast("PDF Imported successfully!");
                
            } catch (error) {
                console.error("Auto-import failed (likely CORS)", error);
                // Fallback
                window.open(url, '_blank');
                showToast("Opened in new tab. Download and upload manually.");
            }
        }

        // Easter Eggs
        const easterEggs = { "sthitirupa mukherjee": { name: "Sthitirupa Mukherjee", bio: "Editor of Daag Magazine", img: "https://res.cloudinary.com/dpnpu5vn5/image/upload/v1766758483/Stritirupa_bzf7p7.png", emojis: ['‚úçÔ∏è', 'üìÑ'] }, "farhan aktar": { name: "Farhan Aktar", bio: "Founder of Daag", img: "https://res.cloudinary.com/dpnpu5vn5/image/upload/v1766761391/farhan_daag_yvu8xn.png", emojis: ['üíª', 'üìΩÔ∏è'] }, "shamekha wazed": { name: "Shamekha Wazed", bio: "Graphic Designer, Illustrator", img: "https://res.cloudinary.com/dpnpu5vn5/image/upload/v1766761390/Shamekha_daag_fhrlvs.png", emojis: ['üé®', 'üë©üèª‚Äçüé®'] }, "bidisha ghosh": { name: "Bidisha Ghosh", bio: "Event Management", img: "https://res.cloudinary.com/dpnpu5vn5/image/upload/v1766761389/Bidisha_daag_j2g7xm.png", emojis: ['üé§', 'üìÖ'] }, "saina azmi": { name: "Saina Azmi", bio: "Classical dancer", img: "https://res.cloudinary.com/dpnpu5vn5/image/upload/v1766761391/Saina_daag_qvfkvp.png", emojis: ['üíÉüèª', '‚úàÔ∏è'] }, "anantez": { name: "Anantez", bio: "Creative Consultant at Daag", img: "https://res.cloudinary.com/dpnpu5vn5/image/upload/v1769701458/aayush_icon_nv0dvp.png", emojis: ['ü´∂', '‚ú®'] } };
        function triggerEmojiShower(emojiList) { const container = document.getElementById('emojiContainer'); container.classList.add('active'); for(let i=0; i<25; i++) { setTimeout(() => { const el = document.createElement('div'); el.className = 'float-emoji'; el.textContent = emojiList[Math.floor(Math.random() * emojiList.length)]; el.style.left = Math.floor(Math.random() * 95) + 'vw'; const duration = 3 + Math.random() * 2; el.style.animationDuration = `${duration}s`; container.appendChild(el); setTimeout(() => { if(el.parentNode) el.remove(); }, duration * 1000); }, i * 120); } setTimeout(() => { container.classList.remove('active'); }, 6000); }

        // Research Search Function
        async function runRobustSearch(e) { e.preventDefault(); const input = document.getElementById('search-input'); const query = input.value.trim(); if (!query) return; state.search.query = query; state.search.searched = true; state.search.easterEgg = null; state.search.loading = true; const lowerQuery = query.toLowerCase(); if (easterEggs[lowerQuery]) { state.search.easterEgg = easterEggs[lowerQuery]; state.search.results = []; state.search.loading = false; renderView(); triggerEmojiShower(state.search.easterEgg.emojis); return; } renderView(); const sources = state.search.sources; const promises = []; if(sources.openalex) promises.push(safeFetch(fetchOpenAlex(query))); if(sources.crossref) promises.push(safeFetch(fetchCrossref(query))); if(sources.internetarchive) promises.push(safeFetch(fetchInternetArchive(query))); const handoffs = [ {id: 'jstor', name: 'JSTOR', url: `https://www.jstor.org/action/doBasicSearch?Query=${encode(query)}&acc=off&wc=on`}, {id: 'muse', name: 'Project MUSE', url: `https://muse.jhu.edu/search?action=search&query=${encode(query)}`} ]; try { const resultsArrays = await Promise.all(promises); let allItems = resultsArrays.flat(); handoffs.forEach(h => { if(sources[h.id]) { allItems.push({ title: `Search ${h.name} for "${query}"`, url: h.url, source: h.name, date: '', snippet: 'External database search (Handoff)', isHandoff: true, authors: [] }); } }); const seen = new Set(); allItems = allItems.filter(item => { const key = item.url; if(seen.has(key)) return false; seen.add(key); return true; }); allItems.sort((a, b) => { if(a.isHandoff !== b.isHandoff) return a.isHandoff ? 1 : -1; const dateA = parseInt(a.date) || 0; const dateB = parseInt(b.date) || 0; return dateB - dateA; }); state.search.results = allItems; } catch (err) { console.error(err); state.search.results = []; } finally { state.search.loading = false; renderView(); } }

        function toggleSource(source) { state.search.sources[source] = !state.search.sources[source]; renderView(); }
        function togglePdfsOnly() { state.search.pdfsOnly = !state.search.pdfsOnly; renderView(); }
        function addToLibrary(paperIndex) { const paper = state.search.results[paperIndex]; const libPaper = { id: paper.url || Date.now().toString(), title: paper.title, authors: paper.authors || [], year: paper.date, journal: paper.journal || paper.source, url: paper.url }; if (!state.library.find(p => p.id === libPaper.id)) { state.library.push(libPaper); saveData(); showToast("Added to Citations"); renderNav(); } else { showToast("Already in Library"); } }

        // Render Research
        function renderResearch(container) {
            container.innerHTML = `
                <div class="h-full flex flex-col p-4 md:p-12 overflow-y-auto pb-24 md:pb-12">
                    <!-- Mobile Logo (Above Search) -->
                    <div class="md:hidden w-full flex justify-center mb-6">
                        <img src="https://res.cloudinary.com/dpnpu5vn5/image/upload/v1770818336/HuResearch_Logo_cjq8pf.png" alt="HuResearch" class="h-10 object-contain">
                    </div>

                    <div class="w-full max-w-4xl mx-auto mb-8 md:mb-12">
                        <div class="bg-white rounded-2xl shadow-sm border border-stone-200 p-2">
                            <form onsubmit="runRobustSearch(event)" class="flex items-center gap-2 p-1">
                                <input id="search-input" type="text" placeholder="Keywords, Titles, or Authors..." value="${state.search.query}" class="flex-1 bg-transparent border-none outline-none text-base md:text-lg px-2 md:px-4 text-stone-800 placeholder:text-stone-300 h-10 md:h-12 w-full min-w-0">
                                <button type="submit" class="bg-black text-white px-4 md:px-8 h-10 md:h-12 rounded-xl font-medium hover:bg-stone-800 transition-colors flex items-center gap-2 shrink-0">
                                    ${state.search.loading ? '<i data-lucide="loader-2" class="animate-spin"></i>' : '<span class="hidden md:inline">Search</span><i data-lucide="search" class="md:hidden"></i>'}
                                </button>
                            </form>
                            <div class="flex flex-wrap items-center gap-2 px-2 md:px-4 pb-4 pt-2 border-t border-stone-100 mt-2 overflow-x-auto no-scrollbar">
                                <label class="filter-label pdf-toggle"><input type="checkbox" ${state.search.pdfsOnly ? 'checked' : ''} onchange="togglePdfsOnly()"><span>PDFs Only</span></label>
                                <div class="w-px h-4 bg-stone-200 mx-1 hidden md:block"></div>
                                <label class="filter-label"><input type="checkbox" ${state.search.sources.openalex ? 'checked' : ''} onchange="toggleSource('openalex')"><span>OpenAlex</span></label>
                                <label class="filter-label"><input type="checkbox" ${state.search.sources.crossref ? 'checked' : ''} onchange="toggleSource('crossref')"><span>Crossref</span></label>
                                <label class="filter-label"><input type="checkbox" ${state.search.sources.internetarchive ? 'checked' : ''} onchange="toggleSource('internetarchive')"><span>Archive</span></label>
                                <div class="w-px h-4 bg-stone-200 mx-1 hidden md:block"></div>
                                <label class="filter-label"><input type="checkbox" ${state.search.sources.jstor ? 'checked' : ''} onchange="toggleSource('jstor')"><span>JSTOR</span></label>
                                <label class="filter-label"><input type="checkbox" ${state.search.sources.muse ? 'checked' : ''} onchange="toggleSource('muse')"><span>MUSE</span></label>
                            </div>
                        </div>
                    </div>
                    <div class="w-full max-w-4xl mx-auto flex-1" id="research-results-container"></div>
                </div>
            `;
            const resultsContainer = document.getElementById('research-results-container');
            if (state.search.easterEgg) { const ee = state.search.easterEgg; resultsContainer.innerHTML = `<div class="easter-egg-card active"><img src="${ee.img}" alt="" class="ee-img"><div class="ee-name">${ee.name}</div><div class="ee-bio">${ee.bio}</div></div>`; return; }
            
            // LOADING ANIMATION (ROTATING GLOBE)
            if (state.search.loading) {
                resultsContainer.innerHTML = `
                    <div class="flex flex-col items-center justify-center h-48 md:h-64 text-stone-400">
                        <i data-lucide="globe" width="48" class="mb-4 opacity-50 animate-spin-slow text-stone-600"></i>
                        <p class="animate-pulse text-sm font-medium">Fetching original papers...</p>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            if (!state.search.searched) { resultsContainer.innerHTML = `<div class="flex flex-col items-center justify-center h-48 md:h-64 text-stone-400"><p>Start your research.</p></div>`; lucide.createIcons(); return; }
            const items = state.search.results;
            const visibleItems = state.search.pdfsOnly ? items.filter(i => !!i.pdf || i.isOpenAccess) : items;
            if (visibleItems.length === 0) { resultsContainer.innerHTML = '<div class="text-center py-10 text-stone-500">No results found matching filters.</div>'; return; }
            resultsContainer.appendChild(mkEl('div', 'text-center text-stone-400 text-sm mb-4', `Found ${visibleItems.length} results${state.search.pdfsOnly ? ' (PDFs Only)' : ''}.`));
            visibleItems.forEach((item, idx) => { 
                const card = mkEl('div', `result-card ${item.isHandoff ? 'handoff' : ''}`); 
                const header = mkEl('div', 'flex justify-between items-start gap-4'); 
                const titleBlock = mkEl('div', 'flex-1'); 
                const titleLink = mkEl('a', 'res-title', item.title); 
                titleLink.href = item.url; titleLink.target = '_blank'; 
                highlightText(titleLink, state.search.query); 
                titleBlock.appendChild(titleLink); 
                
                const metaLine = [item.source, item.date, item.journal].filter(Boolean).join(' ¬∑ '); 
                titleBlock.appendChild(mkEl('div', 'res-meta', metaLine)); 
                header.appendChild(titleBlock); 
                
                if (!item.isHandoff) { 
                    // PROMINENT ADD BUTTON
                    const addBtn = mkEl('button', 'add-btn-prominent', ''); 
                    addBtn.innerHTML = '<i data-lucide="plus" width="20"></i>'; 
                    addBtn.onclick = () => addToLibrary(idx); 
                    header.appendChild(addBtn); 
                } 
                card.appendChild(header); 
                
                if (item.snippet) { 
                    const snippetDiv = mkEl('div', 'res-snippet', item.snippet); 
                    highlightText(snippetDiv, state.search.query); 
                    card.appendChild(snippetDiv); 
                } 
                
                const footer = mkEl('div', 'res-footer'); 
                if (item.pdf) { 
                    // SMART PDF BUTTON
                    const pdfBtn = mkEl('button', 'badge pdf', 'PDF'); // Changed from <a> to <button> for custom logic
                    pdfBtn.style.cursor = 'pointer';
                    pdfBtn.onclick = () => importExternalPDF(item.pdf, item.title);
                    footer.appendChild(pdfBtn); 
                } 
                if (item.doi) { 
                    const doiBtn = mkEl('a', 'badge', 'DOI'); 
                    doiBtn.href = `https://doi.org/${item.doi}`; doiBtn.target = '_blank'; 
                    footer.appendChild(doiBtn); 
                } 
                if (!item.isHandoff) { 
                    const citeBtn = mkEl('button', 'copy-btn', 'Cite (MLA)'); 
                    citeBtn.onclick = () => { 
                        const citation = citeMLA(item); 
                        // FALLBACK COPY FOR SECURE CONTEXT
                        const textArea = document.createElement("textarea");
                        textArea.value = citation;
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                            document.execCommand('copy');
                            citeBtn.textContent = 'Copied!'; 
                            setTimeout(() => { citeBtn.textContent = 'Cite (MLA)'; }, 2000); 
                        } catch (err) {
                            console.error('Copy failed', err);
                        }
                        document.body.removeChild(textArea);
                    }; 
                    footer.appendChild(citeBtn); 
                } else { 
                    footer.appendChild(mkEl('span', 'badge', 'External Database')); 
                } 
                card.appendChild(footer); 
                resultsContainer.appendChild(card); 
            });
            lucide.createIcons();
        }

        // Citations Logic
        function citeMLA(item) { const authors = item.authors?.length ? item.authors.map(a => `${a.last || a.display_name}`).join(', ') : ''; const title = item.title ? `"${item.title}."` : ''; const journal = item.journal ? `${item.journal},` : ''; const year = item.date ? `${item.date},` : ''; const url = item.url || ''; const accessDate = new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }); return [authors, title, journal, year, url, `Accessed ${accessDate}.`].filter(Boolean).join(' '); }
        function formatCitationText(paper, style) { const authors = paper.authors.map(a => a.name || a.display_name).join(', '); if (style === 'MLA') return `${authors}. "${paper.title}." ${paper.journal}, ${paper.year}, ${paper.url}.`; if (style === 'Chicago') return `${authors}. "${paper.title}." ${paper.journal} (${paper.year}). ${paper.url}.`; return `${authors} (${paper.year}). ${paper.title}. ${paper.journal}. ${paper.url}`; }
        function setCitationStyle(style) { state.citations.style = style; renderView(); }
        
        function copyCitationText(id) { 
            const paper = state.library.find(p => p.id === id);
            if (!paper) return;
            const text = formatCitationText(paper, state.citations.style);
            
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showToast("Citation copied to clipboard");
            } catch (err) {
                console.error('Copy failed', err);
                showToast("Failed to copy");
            }
            document.body.removeChild(textArea);

            state.citations.copiedId = id; 
            renderView(); 
            setTimeout(() => { 
                state.citations.copiedId = null; 
                if(state.activeTab === 'citations') renderView(); 
            }, 2000); 
        }

        function removeCitation(id) { state.library = state.library.filter(p => p.id !== id); saveData(); renderNav(); renderView(); }
        
        async function generateCitationFromID() {
            const inputEl = document.getElementById('doi-isbn-input');
            let val = inputEl.value.trim();
            if (!val) return;

            // Clean prefixes
            val = val.replace(/^(https?:\/\/)?(dx\.)?doi\.org\//i, '');
            val = val.replace(/^(urn:)?isbn:/i, '').trim();
            
            const isDOI = val.startsWith('10.');
            const cleanIsbn = val.replace(/[\s-]/g, '').toUpperCase();
            const isISBN = (cleanIsbn.length === 10 || cleanIsbn.length === 13) && !isDOI;

            if (!isDOI && !isISBN) {
                showToast("Please enter a valid DOI (starts with 10.) or ISBN.");
                return;
            }

            inputEl.disabled = true;
            const originalText = inputEl.value;
            inputEl.value = 'Fetching...';

            try {
                let paperObj = null;

                if (isDOI) {
                    const res = await fetch(`https://api.crossref.org/works/${encodeURIComponent(val)}`);
                    if (!res.ok) throw new Error("DOI not found");
                    const data = await res.json();
                    const item = data.message;
                    
                    paperObj = {
                        id: item.URL || val,
                        title: item.title?.[0] || 'Unknown Title',
                        authors: item.author ? item.author.map(a => ({ display_name: (a.given ? a.given + ' ' : '') + a.family })) : [],
                        year: item.created?.['date-parts']?.[0]?.[0] ? String(item.created['date-parts'][0][0]) : '',
                        journal: item['container-title']?.[0] || 'Unknown Publication',
                        url: item.URL || `https://doi.org/${val}`
                    };
                } else if (isISBN) {
                    const res = await fetch(`https://openlibrary.org/api/books?bibkeys=ISBN:${cleanIsbn}&format=json&jscmd=data`);
                    if (!res.ok) throw new Error("ISBN fetch failed");
                    const data = await res.json();
                    const bookKey = `ISBN:${cleanIsbn}`;
                    const item = data[bookKey];
                    
                    if (!item) throw new Error("ISBN not found");

                    paperObj = {
                        id: item.url || val,
                        title: item.title || 'Unknown Title',
                        authors: item.authors ? item.authors.map(a => ({ display_name: a.name })) : [],
                        year: item.publish_date ? item.publish_date.match(/\d{4}/)?.[0] || item.publish_date : '',
                        journal: item.publishers?.[0]?.name || 'Unknown Publisher',
                        url: item.url || `https://openlibrary.org/isbn/${cleanIsbn}`
                    };
                }

                if (paperObj) {
                    if (!state.library.find(p => p.id === paperObj.id)) {
                        state.library.push(paperObj);
                        saveData();
                        renderNav();
                        renderView(); 
                        showToast("Citation generated and added!");
                    } else {
                        showToast("This item is already in your library.");
                        inputEl.value = originalText;
                        inputEl.disabled = false;
                    }
                }
            } catch (error) {
                console.error(error);
                showToast("Failed to fetch metadata. Check ID.");
                inputEl.value = originalText;
                inputEl.disabled = false;
            }
        }

        function renderCitations(container) { 
            const styles = ['APA', 'MLA', 'Chicago']; 
            // UPDATED PLACEHOLDER AND BUTTON TEXT (WITHOUT ICON)
            container.innerHTML = `<div class="h-full p-4 md:p-12 overflow-y-auto pb-24 md:pb-12"><div class="max-w-4xl mx-auto"><div class="flex flex-col md:flex-row justify-between items-start md:items-end mb-6 md:mb-8 gap-4"><div><h2 class="text-2xl md:text-3xl font-bold text-stone-900 mb-1">My Bibliography</h2><p class="text-stone-500">${state.library.length} references saved</p></div><div class="flex items-center gap-1 bg-white p-1 rounded-lg border border-stone-200">${styles.map(s => `<button onclick="setCitationStyle('${s}')" class="px-3 py-1.5 rounded-md text-xs font-medium transition-all ${state.citations.style === s ? 'bg-black text-white' : 'text-stone-500 hover:bg-stone-50'}">${s}</button>`).join('')}</div></div><div class="bg-white p-2 rounded-xl border border-stone-200 shadow-sm mb-6 flex gap-2 items-center"><input id="doi-isbn-input" type="text" placeholder="Generate citation using DOI or ISBN..." class="flex-1 bg-transparent border-none px-3 py-2 text-sm outline-none text-stone-800 placeholder-stone-400" onkeydown="if(event.key === 'Enter') generateCitationFromID()"><button onclick="generateCitationFromID()" class="bg-stone-900 text-white px-4 py-2 rounded-lg text-xs font-medium hover:bg-stone-800 transition-colors whitespace-nowrap">Generate</button></div>${state.library.length === 0 ? `<div class="text-center py-20 border-2 border-dashed border-stone-200 rounded-2xl"><i data-lucide="quote" width="48" class="mx-auto text-stone-300 mb-4"></i><p class="text-stone-400">Add papers from Research tab or enter an ID above</p></div>` : `<div class="bg-white rounded-2xl shadow-sm border border-stone-200 overflow-hidden">${state.library.map((paper, idx) => { const text = formatCitationText(paper, state.citations.style); const isCopied = state.citations.copiedId === paper.id; return `<div class="p-4 md:p-6 border-b border-stone-100 last:border-0 hover:bg-stone-50/50 group"><div class="flex gap-3"><div class="text-stone-300 font-mono text-sm pt-1 w-6 shrink-0">${idx + 1}.</div><div class="flex-1"><p class="text-stone-800 font-serif text-base mb-3 leading-relaxed">${text}</p><div class="flex flex-wrap items-center gap-2 mb-2"><button onclick="copyCitationText('${paper.id}')" class="text-xs font-medium px-3 py-1.5 rounded-full border flex items-center gap-2 ${isCopied ? 'bg-green-50 text-green-700 border-green-200' : 'bg-white text-stone-600 border-stone-200 hover:border-stone-400'}"><i data-lucide="${isCopied ? 'check' : 'copy'}" width="12"></i> ${isCopied ? 'Copied' : 'Copy'}</button>${paper.url ? `<a href="${paper.url}" target="_blank" class="text-xs font-medium text-blue-600 hover:text-blue-800 px-2 py-1 flex items-center gap-1"><i data-lucide="external-link" width="12"></i> View Source</a>` : ''}<button onclick="removeCitation('${paper.id}')" class="text-xs font-medium text-red-400 hover:text-red-600 px-2 py-1">Remove</button></div></div></div></div>`; }).join('')}</div>`}</div></div>`; 
        }

        // --- PDF Manager & Editor ---
        function handleFileUpload(input) {
            const file = input.files[0];
            if (file && file.type === 'application/pdf') {
                const id = Date.now().toString();
                const newPdf = {
                    id: id,
                    name: file.name,
                    blob: file, // Store blob for DB
                    url: URL.createObjectURL(file),
                    date: new Date().toLocaleDateString()
                };
                
                // Save to state and DB
                state.pdfs.push(newPdf);
                savePDFToDB({ id: newPdf.id, name: newPdf.name, blob: newPdf.blob, date: newPdf.date });
                
                openPdf(state.pdfs.length - 1);
                renderNav();
            }
        }

        async function deletePdf(index) {
            if(!confirm("Are you sure you want to remove this PDF?")) return;
            const pdf = state.pdfs[index];
            state.pdfs.splice(index, 1);
            
            // Cleanup annotations
            delete state.annotations[pdf.id];
            saveData();
            
            // Remove from DB
            await deletePDFFromDB(pdf.id);
            
            // Re-render
            renderNav();
            renderView();
            showToast("PDF removed");
        }

        function renderPDFList(container) {
            container.innerHTML = `<div class="h-full p-4 md:p-12 overflow-y-auto pb-24 md:pb-12"><div class="max-w-4xl mx-auto"><div class="flex justify-between items-center mb-6"><div><h2 class="text-2xl md:text-3xl font-bold text-stone-900">My Library</h2><p class="text-stone-500">Read & Annotate</p></div><button onclick="document.getElementById('pdf-upload').click()" class="bg-black text-white px-4 py-2 rounded-xl font-medium flex items-center gap-2 text-sm shadow-lg"><i data-lucide="plus" width="18"></i> Upload PDF</button><input type="file" id="pdf-upload" accept=".pdf" class="hidden" onchange="handleFileUpload(this)"></div>${state.pdfs.length === 0 ? `<div class="border-2 border-dashed border-stone-200 rounded-2xl flex flex-col items-center justify-center h-48 bg-stone-50 text-center"><i data-lucide="download" width="32" class="text-stone-400 mb-2"></i><p class="text-stone-600 font-medium">No PDFs uploaded</p></div>` : `<div class="grid grid-cols-1 md:grid-cols-3 gap-4">${state.pdfs.map((pdf, idx) => `<div class="bg-white rounded-xl border border-stone-200 p-4 hover:shadow-lg flex flex-col h-40 justify-between relative group"><button onclick="deletePdf(${idx})" class="absolute top-2 right-2 p-2 text-stone-300 hover:text-red-500 z-10"><i data-lucide="trash-2" width="16"></i></button><div onclick="openPdf(${idx})" class="cursor-pointer flex-1 flex flex-col justify-between"><div class="flex items-start gap-3"><div class="w-10 h-14 bg-red-50 border border-red-100 rounded flex items-center justify-center"><i data-lucide="file-text" class="text-red-400" width="20"></i></div><div class="pr-6 min-w-0 flex-1"><h4 class="font-semibold text-stone-800 line-clamp-2 text-sm break-words">${pdf.name}</h4><p class="text-xs text-stone-400">${pdf.date}</p></div></div><div class="flex items-center gap-2 mt-4 text-xs font-medium text-stone-500"><i data-lucide="pen-tool" width="12"></i> ${state.annotations[pdf.id]?.length || 0} Notes</div></div></div>`).join('')}</div>`}</div></div>`;
        }

        async function openPdf(index) {
            const pdf = state.pdfs[index];
            state.pdfViewer.activePdf = pdf;
            state.pdfViewer.pageNum = 1;
            state.pdfViewer.scale = 1.0;
            state.pdfViewer.highlightMode = false;
            state.pdfViewer.commentMode = false;
            
            // Render the shell immediately to show the loading state
            renderView(); 
            
            try {
                const loadingTask = pdfjsLib.getDocument(pdf.url);
                state.pdfViewer.pdfDoc = await loadingTask.promise;
                state.pdfViewer.numPages = state.pdfViewer.pdfDoc.numPages;
                
                // Immediately update DOM to show correct page count for the floating capsule
                const countEl = document.getElementById('page-count');
                if(countEl) countEl.textContent = state.pdfViewer.numPages;
                
                renderPDFPage(1);
            } catch (error) { 
                console.error(error);
                showToast("Error loading PDF"); 
            }
        }

        function closePdf() { state.pdfViewer.activePdf = null; state.pdfViewer.pdfDoc = null; renderView(); }

        // --- DRAWING & COMMENTING LOGIC ---
        let isDrawing = false;
        let startX = 0, startY = 0;
        let currentRect = null;

        // Zoom Functions
        function zoomIn() {
            state.pdfViewer.scale += 0.2;
            renderPDFPage(state.pdfViewer.pageNum);
        }

        function zoomOut() {
            if(state.pdfViewer.scale > 0.4) {
                state.pdfViewer.scale -= 0.2;
                renderPDFPage(state.pdfViewer.pageNum);
            }
        }

        // Jump to Page function for annotation cards
        function jumpToPage(num) {
            if (state.pdfViewer.pageNum !== num) {
                renderPDFPage(num);
            }
            if (window.innerWidth < 768 && state.pdfViewer.mobileNotesOpen) {
                toggleMobileNotes();
            }
        }

        async function renderPDFPage(num) {
            if (!state.pdfViewer.pdfDoc) return;
            state.pdfViewer.pageNum = num;
            
            // Update page number display
            const pageNumDisplay = document.getElementById('page-num');
            if(pageNumDisplay) pageNumDisplay.textContent = num;

            const page = await state.pdfViewer.pdfDoc.getPage(num);
            const container = document.getElementById('pdf-render-container');
            const wrapper = document.getElementById('pdf-wrapper');
            
            // Reset wrapper transform for clean visual scale
            if(wrapper) {
                wrapper.style.transition = 'none';
                wrapper.style.transform = 'translateX(0px) scale(1)';
            }
            
            // Responsive base scale calculation
            const containerWidth = container.clientWidth - 40;
            const unscaledViewport = page.getViewport({ scale: 1.0 });
            const baseScale = containerWidth / unscaledViewport.width;
            const effectiveScale = baseScale * state.pdfViewer.scale;

            const viewport = page.getViewport({ scale: effectiveScale });
            
            // High DPI support
            const dpr = window.devicePixelRatio || 1;
            
            // Setup Canvas
            const canvas = document.getElementById('the-canvas');
            const context = canvas.getContext('2d');
            
            canvas.width = Math.floor(viewport.width * dpr);
            canvas.height = Math.floor(viewport.height * dpr);
            canvas.style.width = Math.floor(viewport.width) + "px";
            canvas.style.height = Math.floor(viewport.height) + "px";
            
            // Scale context for retina
            context.scale(dpr, dpr);

            // Setup Layers
            const layerStyleW = Math.floor(viewport.width) + "px";
            const layerStyleH = Math.floor(viewport.height) + "px";

            const hlLayer = document.getElementById('highlight-layer');
            hlLayer.style.width = layerStyleW;
            hlLayer.style.height = layerStyleH;
            hlLayer.innerHTML = ''; 

            const textLayerDiv = document.getElementById('text-layer');
            textLayerDiv.style.width = layerStyleW;
            textLayerDiv.style.height = layerStyleH;
            textLayerDiv.innerHTML = '';

            // Render saved highlights/comments
            const pdfId = state.pdfViewer.activePdf.id;
            const savedAnns = state.annotations[pdfId] || [];
            
            savedAnns.filter(a => a.type === 'highlight' && a.page === num).forEach(h => {
                const rect = document.createElement('div');
                rect.className = 'drawn-highlight';
                rect.style.left = `${h.rect.x * 100}%`;
                rect.style.top = `${h.rect.y * 100}%`;
                rect.style.width = `${h.rect.w * 100}%`;
                rect.style.height = `${h.rect.h * 100}%`;
                hlLayer.appendChild(rect);
            });

            savedAnns.filter(a => a.type === 'comment' && a.page === num).forEach(c => {
                const marker = document.createElement('div');
                marker.className = 'comment-marker';
                marker.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7.9 20A9 9 0 1 0 4 16.1L2 22Z"/></svg>';
                marker.style.left = `${c.x * 100}%`;
                marker.style.top = `${c.y * 100}%`;
                marker.onclick = (e) => { e.stopPropagation(); editComment(c.id); };
                hlLayer.appendChild(marker);
            });

            // Render Canvas
            const renderContext = {
                canvasContext: context,
                viewport: viewport
            };
            await page.render(renderContext).promise;

            // Render Text Layer
            const textContent = await page.getTextContent();
            pdfjsLib.renderTextLayer({
                textContentSource: textContent,
                container: textLayerDiv,
                viewport: viewport,
                textDivs: []
            });
            
            toggleLayerMode();
        }

        function prevPage() { if (state.pdfViewer.pageNum <= 1) return; renderPDFPage(state.pdfViewer.pageNum - 1); }
        function nextPage() { if (state.pdfViewer.pageNum >= state.pdfViewer.numPages) return; renderPDFPage(state.pdfViewer.pageNum + 1); }
        
        // --- Pinch Zoom & Swipe Drag Logic ---
        let initialPinchDistance = null;
        let initialScale = 1;
        let isZooming = false; 
        
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let isSwiping = false; // Flag to differentiate between scrolling down and swiping horizontally
        
        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                // Pinch Start
                isZooming = true;
                initialPinchDistance = getPinchDistance(e);
                initialScale = state.pdfViewer.scale; 
            } else if (!state.pdfViewer.highlightMode && !state.pdfViewer.commentMode && !isZooming) {
                // Only track swipe if not zooming
                touchStartX = e.touches[0].screenX;
                touchStartY = e.touches[0].screenY;
                isSwiping = false; // Reset on new touch
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length === 2 && initialPinchDistance) {
                isZooming = true;
                e.preventDefault(); // Stop native gestures during pinch
                
                const currentDistance = getPinchDistance(e);
                const scaleFactor = currentDistance / initialPinchDistance;
                // Temporarily scale via CSS for performance
                const wrapper = document.querySelector('.pdf-page-wrapper');
                if(wrapper) {
                    wrapper.style.transform = `scale(${scaleFactor})`;
                }
            } else if (e.touches.length === 1 && !isZooming && state.pdfViewer.scale <= 1.05 && !state.pdfViewer.highlightMode && !state.pdfViewer.commentMode) {
                // Handle visual drag for swipe-to-change-page if NOT zoomed in
                const deltaX = e.touches[0].screenX - touchStartX;
                const deltaY = e.touches[0].screenY - touchStartY;
                
                // Determine if user intends to swipe horizontally vs scroll vertically
                if (!isSwiping && Math.abs(deltaX) > 10 && Math.abs(deltaX) > Math.abs(deltaY)) {
                    isSwiping = true;
                }
                
                if (isSwiping) {
                    e.preventDefault(); // Stop vertical scroll while swiping page
                    const wrapper = document.getElementById('pdf-wrapper');
                    if (wrapper) {
                        wrapper.style.transition = 'none';
                        wrapper.style.transform = `translateX(${deltaX}px)`;
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length < 2 && isZooming) {
                initialPinchDistance = null;
                const wrapper = document.querySelector('.pdf-page-wrapper');
                if(wrapper) {
                    wrapper.style.transition = "transform 0.2s";
                    wrapper.style.transform = "translateX(0px) scale(1)";
                }
                setTimeout(() => { isZooming = false; }, 300);
            }
            
            if (!state.pdfViewer.highlightMode && !state.pdfViewer.commentMode && !initialPinchDistance && !isZooming) {
                touchEndX = e.changedTouches[0].screenX;
                
                // If we were swiping the page physically, handle snap back or flip
                if (state.pdfViewer.scale <= 1.05) {
                    const deltaX = touchEndX - touchStartX;
                    const wrapper = document.getElementById('pdf-wrapper');
                    
                    if (deltaX < -60) {
                        nextPage();
                    } else if (deltaX > 60) {
                        prevPage();
                    } else {
                        // Snap back if didn't swipe far enough
                        if (wrapper && isSwiping) {
                            wrapper.style.transition = 'transform 0.3s ease-out';
                            wrapper.style.transform = 'translateX(0px) scale(1)';
                        }
                    }
                }
            }
        }

        function getPinchDistance(e) {
            return Math.hypot(
                e.touches[0].pageX - e.touches[1].pageX,
                e.touches[0].pageY - e.touches[1].pageY
            );
        }

        function toggleMobileNotes() {
            state.pdfViewer.mobileNotesOpen = !state.pdfViewer.mobileNotesOpen;
            const sidebar = document.getElementById('notes-sidebar');
            sidebar.classList.toggle('translate-x-full'); sidebar.classList.toggle('translate-x-0');
            
            const pagination = document.querySelector('.floating-pagination');
            if (pagination) {
                if (state.pdfViewer.mobileNotesOpen) {
                    pagination.classList.add('hide-on-mobile');
                } else {
                    pagination.classList.remove('hide-on-mobile');
                }
            }
        }

        // --- INTERACTION MODES (Highlight & Comment) ---
        function toggleHighlightMode() {
            state.pdfViewer.highlightMode = !state.pdfViewer.highlightMode;
            if(state.pdfViewer.highlightMode) state.pdfViewer.commentMode = false;
            updateToolbarUI();
            toggleLayerMode();
            if(state.pdfViewer.highlightMode) showToast("Draw box to highlight");
        }

        function toggleCommentMode() {
            state.pdfViewer.commentMode = !state.pdfViewer.commentMode;
            if(state.pdfViewer.commentMode) state.pdfViewer.highlightMode = false;
            updateToolbarUI();
            toggleLayerMode();
            if(state.pdfViewer.commentMode) showToast("Tap on PDF to add comment");
        }

        function updateToolbarUI() {
            const hBtn = document.getElementById('highlight-btn');
            const cBtn = document.getElementById('comment-mode-btn');
            if(hBtn) {
                if(state.pdfViewer.highlightMode) hBtn.classList.add('tool-btn-active');
                else hBtn.classList.remove('tool-btn-active');
            }
            if(cBtn) {
                if(state.pdfViewer.commentMode) cBtn.classList.add('comment-btn-active');
                else cBtn.classList.remove('comment-btn-active');
            }
        }

        function toggleLayerMode() {
            const layer = document.getElementById('highlight-layer');
            if(layer) {
                layer.classList.remove('drawing-mode', 'comment-mode');
                if(state.pdfViewer.highlightMode) layer.classList.add('drawing-mode');
                if(state.pdfViewer.commentMode) layer.classList.add('comment-mode');
            }
        }

        // --- Interaction Handlers ---
        function handleLayerClick(e) {
            if(!state.pdfViewer.commentMode) return;
            
            const layer = document.getElementById('highlight-layer');
            const rect = layer.getBoundingClientRect();
            const relX = (e.clientX - rect.left) / rect.width;
            const relY = (e.clientY - rect.top) / rect.height;
            
            openCommentModal(relX, relY);
        }

        // --- Comment Modal Logic ---
        function openCommentModal(x, y, existingId = null) {
            const modal = document.getElementById('comment-modal');
            const textarea = document.getElementById('comment-text');
            const title = document.getElementById('comment-modal-title');
            
            state.pdfViewer.editingCommentId = existingId;
            
            if(!existingId) {
                state.pdfViewer.tempLocation = { x, y, page: state.pdfViewer.pageNum };
                textarea.value = '';
                title.textContent = "Add a comment";
            } else {
                const pdfId = state.pdfViewer.activePdf.id;
                const ann = state.annotations[pdfId].find(a => a.id === existingId);
                if(ann) {
                    textarea.value = ann.text;
                    title.textContent = "Edit comment";
                }
            }
            
            modal.classList.remove('hidden');
            textarea.focus();
        }

        function closeCommentModal() {
            document.getElementById('comment-modal').classList.add('hidden');
            state.pdfViewer.tempLocation = null;
            state.pdfViewer.editingCommentId = null;
        }

        function saveComment() {
            const text = document.getElementById('comment-text').value.trim();
            if(!text) return;

            const pdfId = state.pdfViewer.activePdf.id;
            if(!state.annotations[pdfId]) state.annotations[pdfId] = [];

            if(state.pdfViewer.editingCommentId) {
                const idx = state.annotations[pdfId].findIndex(a => a.id === state.pdfViewer.editingCommentId);
                if(idx > -1) {
                    state.annotations[pdfId][idx].text = text;
                    state.annotations[pdfId][idx].timestamp = new Date().toLocaleString();
                }
                showToast("Comment updated");
            } else {
                const loc = state.pdfViewer.tempLocation;
                state.annotations[pdfId].unshift({
                    id: Date.now(),
                    type: 'comment',
                    text: text,
                    page: loc.page,
                    x: loc.x,
                    y: loc.y,
                    timestamp: new Date().toLocaleString()
                });
                showToast("Comment added");
            }

            saveData();
            renderNotesList();
            renderPDFPage(state.pdfViewer.pageNum);
            closeCommentModal();
        }

        function editComment(id) {
            openCommentModal(null, null, id);
        }

        // --- Drawing Logic ---
        function startDraw(e) {
            if(!state.pdfViewer.highlightMode) return;
            e.preventDefault();
            isDrawing = true;
            
            const rect = e.target.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            startX = clientX - rect.left;
            startY = clientY - rect.top;

            currentRect = document.createElement('div');
            currentRect.className = 'drawn-highlight';
            currentRect.style.left = startX + 'px';
            currentRect.style.top = startY + 'px';
            currentRect.style.width = '0px';
            currentRect.style.height = '0px';
            document.getElementById('highlight-layer').appendChild(currentRect);
        }

        function moveDraw(e) {
            if(!isDrawing || !state.pdfViewer.highlightMode) return;
            e.preventDefault();

            const rect = document.getElementById('highlight-layer').getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const currentX = clientX - rect.left;
            const currentY = clientY - rect.top;

            const width = currentX - startX;
            const height = currentY - startY;

            currentRect.style.width = Math.abs(width) + 'px';
            currentRect.style.height = Math.abs(height) + 'px';
            currentRect.style.left = (width < 0 ? currentX : startX) + 'px';
            currentRect.style.top = (height < 0 ? currentY : startY) + 'px';
        }

        function endDraw(e) {
            if(!isDrawing || !state.pdfViewer.highlightMode) return;
            isDrawing = false;
            
            const layer = document.getElementById('highlight-layer');
            const layerRect = layer.getBoundingClientRect();
            const boxRect = currentRect.getBoundingClientRect();
            
            const relX = (boxRect.left - layerRect.left) / layerRect.width;
            const relY = (boxRect.top - layerRect.top) / layerRect.height;
            const relW = boxRect.width / layerRect.width;
            const relH = boxRect.height / layerRect.height;

            if(relW < 0.01 || relH < 0.01) { currentRect.remove(); return; }

            const pdfId = state.pdfViewer.activePdf.id;
            if(!state.annotations[pdfId]) state.annotations[pdfId] = [];
            
            state.annotations[pdfId].unshift({
                id: Date.now(),
                text: "",
                timestamp: new Date().toLocaleString(),
                type: 'highlight',
                page: state.pdfViewer.pageNum,
                rect: { x: relX, y: relY, w: relW, h: relH }
            });
            
            saveData();
            renderNotesList();
            showToast("Highlight added");
        }

        function addNote(e) {
            e.preventDefault();
            const input = document.getElementById('note-input');
            const text = input.value.trim();
            if(!text) return;
            const pdfId = state.pdfViewer.activePdf.id;
            if(!state.annotations[pdfId]) state.annotations[pdfId] = [];
            state.annotations[pdfId].unshift({ id: Date.now(), text: text, timestamp: new Date().toLocaleString(), type: 'note' });
            input.value = ''; saveData(); renderNotesList();
        }

        function deleteNote(noteId) {
            const pdfId = state.pdfViewer.activePdf.id;
            state.annotations[pdfId] = state.annotations[pdfId].filter(n => n.id !== noteId);
            renderPDFPage(state.pdfViewer.pageNum);
            saveData(); renderNotesList();
        }

        function renderNotesList() {
            const container = document.getElementById('notes-list');
            const notes = state.annotations[state.pdfViewer.activePdf.id] || [];
            if(notes.length === 0) {
                container.innerHTML = '<div class="text-center py-10 text-stone-400 italic text-sm">Draw box to highlight, click to comment, or add notes.</div>';
            } else {
                container.innerHTML = notes.map(note => {
                    const isHighlight = note.type === 'highlight';
                    const isComment = note.type === 'comment';
                    let typeLabel = '';
                    let icon = '';
                    let styleClass = '';
                    
                    if(isHighlight) { typeLabel = `Highlight (Page ${note.page})`; icon = 'box-select'; styleClass = 'highlight-note'; }
                    else if(isComment) { typeLabel = `Comment (Page ${note.page})`; icon = 'message-square'; styleClass = 'comment-note'; }
                    
                    const jumpAttr = note.page ? `onclick="jumpToPage(${note.page})"` : '';
                    const cursorClass = note.page ? 'cursor-pointer hover:border-stone-300' : '';

                    return `
                    <div ${jumpAttr} class="bg-white p-4 rounded-xl border border-stone-200 shadow-sm animate-fade-in-up mb-4 ${styleClass} ${cursorClass}">
                        ${typeLabel ? `<div class="text-xs font-bold text-stone-600 mb-1 flex items-center gap-1 justify-between"><span><i data-lucide="${icon}" width="12" class="inline"></i> ${typeLabel}</span> ${isComment ? `<button onclick="event.stopPropagation(); editComment(${note.id})" class="text-blue-500 hover:text-blue-700 font-normal">Edit</button>` : ''}</div>` : ''}
                        ${note.text ? `<p class="text-stone-800 text-sm whitespace-pre-wrap ${isHighlight ? 'italic' : ''}">${note.text}</p>` : ''}
                        <div class="mt-3 pt-3 border-t border-stone-100 flex justify-between items-center">
                            <span class="text-[10px] text-stone-400">${note.timestamp}</span>
                            <button onclick="event.stopPropagation(); deleteNote(${note.id})" class="text-stone-300 hover:text-red-500"><i data-lucide="trash-2" width="12"></i></button>
                        </div>
                    </div>`;
                }).join('');
            }
            lucide.createIcons();
        }

        function renderPDFReaderDOM(container) {
            const pdf = state.pdfViewer.activePdf;
            container.innerHTML = `
                <div class="flex h-full w-full bg-stone-900 flex-col md:flex-row relative">
                    <div class="flex-1 flex flex-col h-full bg-stone-800 min-h-0 relative">
                        <div class="h-14 bg-stone-900 border-b border-stone-800 flex items-center justify-between px-4 text-stone-400 shrink-0 z-10">
                            <!-- Left: Back & Title -->
                            <div class="flex items-center gap-3 w-1/3">
                                <button onclick="closePdf()" class="hover:text-white flex items-center gap-1 text-xs"><i data-lucide="chevron-right" class="rotate-180" width="16"></i> Back</button>
                                <span class="text-stone-200 font-medium truncate text-xs max-w-[100px] hidden md:block">${pdf.name}</span>
                            </div>
                            
                            <!-- Center: Zoom Controls (New) -->
                            <div class="flex items-center justify-center gap-4 w-1/3">
                                <button onclick="zoomOut()" class="p-1 hover:bg-stone-700 rounded text-stone-400 hover:text-white"><i data-lucide="minus" width="16"></i></button>
                                <button onclick="zoomIn()" class="p-1 hover:bg-stone-700 rounded text-stone-400 hover:text-white"><i data-lucide="plus" width="16"></i></button>
                            </div>

                            <!-- Right: Editing Tools -->
                            <div class="flex items-center justify-end gap-3 w-1/3">
                                <button id="comment-mode-btn" onclick="toggleCommentMode()" class="p-2 hover:bg-stone-700 bg-stone-800 text-stone-400 rounded transition-colors" title="Add Comment"><i data-lucide="message-square-plus" width="18"></i></button>
                                <button id="highlight-btn" onclick="toggleHighlightMode()" class="p-2 hover:bg-stone-700 bg-stone-800 text-stone-400 rounded transition-colors" title="Toggle Draw Highlight"><i data-lucide="highlighter" width="18"></i></button>
                                <button onclick="toggleMobileNotes()" class="md:hidden p-2 rounded text-stone-400"><i data-lucide="pen-tool" width="18"></i></button>
                            </div>
                        </div>
                        <div id="pdf-render-container" 
                             class="flex-1 w-full bg-stone-700 relative" 
                             ontouchstart="handleTouchStart(event)" 
                             ontouchmove="handleTouchMove(event)" 
                             ontouchend="handleTouchEnd(event)">
                             
                             <div id="pdf-wrapper" class="pdf-page-wrapper">
                                <canvas id="the-canvas"></canvas>
                                <div id="highlight-layer" class="highlight-layer"
                                     onclick="handleLayerClick(event)"
                                     onmousedown="startDraw(event)" onmousemove="moveDraw(event)" onmouseup="endDraw(event)"
                                     ontouchstart="startDraw(event)" ontouchmove="moveDraw(event)" ontouchend="endDraw(event)">
                                </div>
                                <div id="text-layer" class="textLayer"></div>
                             </div>
                        </div>
                        <!-- Floating Pagination -->
                        <div class="floating-pagination ${state.pdfViewer.mobileNotesOpen ? 'hide-on-mobile' : ''}">
                            <button onclick="prevPage()" class="hover:text-stone-300"><i data-lucide="chevron-left" width="20"></i></button>
                            <span><span id="page-num">1</span> / <span id="page-count">${state.pdfViewer.numPages || '--'}</span></span>
                            <button onclick="nextPage()" class="hover:text-stone-300"><i data-lucide="chevron-right" width="20"></i></button>
                        </div>
                    </div>
                    <div id="notes-sidebar" class="bg-white border-l border-stone-200 flex flex-col h-full w-full md:w-[350px] fixed inset-0 z-20 md:static md:z-auto transition-transform duration-300 translate-x-full md:translate-x-0">
                        <div class="p-4 border-b border-stone-100 flex justify-between items-center bg-white">
                            <h3 class="font-bold text-lg text-stone-900 flex items-center gap-2"><i data-lucide="pen-tool" width="18"></i> Notes & Highlights</h3>
                            <button onclick="toggleMobileNotes()" class="md:hidden p-2"><i data-lucide="x" width="20"></i></button>
                        </div>
                        <div id="notes-list" class="flex-1 overflow-y-auto p-4 bg-stone-50/30"></div>
                        <div class="p-4 bg-white border-t border-stone-200 pb-20 md:pb-4">
                             <form onsubmit="addNote(event)">
                                <textarea id="note-input" class="w-full bg-stone-100 rounded-xl p-3 text-sm border-none outline-none resize-none h-20" placeholder="Type a note..."></textarea>
                                <div class="flex justify-end mt-2"><button type="submit" class="bg-black text-white px-4 py-1.5 rounded-lg text-xs font-medium">Add Note</button></div>
                             </form>
                        </div>
                    </div>
                </div>`;
            renderNotesList();
            updateToolbarUI();
            if(state.pdfViewer.highlightMode || state.pdfViewer.commentMode) {
                 toggleLayerMode();
            }
        }

        function showToast(msg) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'bg-stone-900 text-white px-4 py-2 rounded-full shadow-lg text-sm animate-fade-in-up flex items-center gap-2 mb-2 pointer-events-auto';
            toast.innerHTML = `<i data-lucide="check" width="14"></i> ${msg}`;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
            lucide.createIcons();
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>